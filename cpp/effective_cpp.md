# Efective cpp

## 将`C++`看做一个语言联邦
从 4 个角度看待这门语言：
1. `C` 语言
2. 面向对象的`C++`
3. 模板编程
4. `STL`

## 尽量以`const` `enum` `inline` 替换 `#define`
1. 对于单纯常量，尽量使用`const` `enum`；
2. 对于函数宏，尽量使用`inline`

## 尽量使用`const`
```c++
char greeting[] = "Hello"; 
char* p = greeting;             // non-const pointer, non-const data
const char* p = greeting;       // non-const pointer, const data
char* const p = greeting;       // const pointer, non-const data
const char* const p = greeting; // const pointer, const data
```

## 确定对象在使用前已经初始化
1. 为内置型对象进行手工初始化，因为C++不保证初始化它们。
2. 构造函数使用成员初值列，而不是构造函数内赋值。
3. 初值列的成员变量排次应该和`class`的声明次序相同。

## 了解`C++`默默编写并调用那些函数
编译器为类创建 默认构造函数、拷贝构造函数、拷贝赋值操作符以及析构函数

## 明确禁用你不希望编译器自动帮你生成的函数
1. 旧的方式是声明为`private`
2. 新的方式是加上`=delete`

## 为多态基类声明`virtual`析构函数
1. 任何`class`只要带有`virtul`函数都几乎确定应该也有一个`virtual`析构函数
2. 对于非基类函数，最好不用虚析构函数

## 绝不在构造析构过程中调用 `virtual`函数
因为只会调用基类的函数；派生函数在构造函数执行前、析构函数开始执行之后不会被当做派生函数看待，而只会执行基类函数

## 令 `operator=` 返回一个 `*this` 的引用

## 拷贝构造函数覆盖所有属性成员

## 用独立的语句将`new`的对象构造智能指针，否则可能导致裸指针创建之后，由于其他错误，导致智能指针未构建就异常了， 最终裸指针导致内存泄露

## 让接口容易被正确使用，不易被误用
1. 接口一致性，与内置类型的行为兼容；
2. 限制类型的操作，束缚对象之，做好资源管理；

## 像设计内置类型`type`那样设计`class`
1. 新`type`的对象应该如何被创建和销毁；
2. 对象的初始化和对象的赋值该有什么样的差别？
3. 新`type`的对象如果被以值传递，意味着什么？
4. 什么是新`type`的合法值？
5. 是否需要某个继承关系？
6. 需要什么样的类型转换？
7. 什么样的操作符和函数对它是合理的？
8. 什么样的标准函数应该抑制？
9. 什么是它的未声明接口？对于效率、安全、资源提供什么保证？
10. 有多么的通用化一般化？
11. 真的需要设计一个新`type`吗？

## 尽量用传`const`引用的方式替代传值
1. 传值的时候，类对象本身以及类的成员都会经历构造析构的过程；以及整个类对应的基类也会经历这样的过程
2. 传值的时候，如果接收的函数形参是基类对象，那么传递的延伸类对象将会被删去衍生类的属性而只保留基类属性。因为引用底层是指针实现的
3. 内置类型可以传值

## 必须返回对象时，别妄想返回其引用
1. 绝不要返回指针或者引用指向的一个`local stack`对象；

## 将成员变量声明的`private`
1. 访问数据的一致性、可细微划分访问控制；
2. `protected`并不比`public`更具封装性；

## 尽可能延后变量定义式的出现时间

## 尽量少做转型动作
1. `const_cast` 去除对象的常量性
2. `dynamic_cast` 用来决定某对象是否归属继承体系中的某个类型，可能代价较大
3. `reinterpret_cast` 低级转型，较少见
4. `static_cast` 强迫隐式转换，`non-const`->`const`, `int` -> `double`